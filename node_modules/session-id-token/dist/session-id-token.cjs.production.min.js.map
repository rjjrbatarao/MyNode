{"version":3,"file":"session-id-token.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["import crypto from 'crypto';\n\n// Length of the session ID portion\nconst idLength = 32;\n\n/**\n * Generate a digitally-signed session ID (a.k.a session token).\n * This is a base64 URL encoded string created from a byte slice\n * where the first `idLength` bytes are crytographically random\n * bytes representing the unique session ID, and the remaining bytes\n * are an HMAC hash of those ID bytes (i.e., a digital signature).\n * The byte slice layout is like so:\n * +-----------------------------------------------------+\n * |...32 crypto random bytes...|HMAC hash of those bytes|\n * +-----------------------------------------------------+\n */\nexport const generateSessionToken = (signingKey: string): string => {\n  if (!signingKey) {\n    throw new Error('Signing key is required');\n  }\n\n  // Cryptographically random bytes\n  const sessionId = crypto.randomBytes(idLength);\n\n  // Create a new HMAC hasher\n  const hmac = crypto.createHmac('sha256', signingKey);\n\n  // Calculate the HMAC signature\n  const signature = Buffer.from(hmac.update(sessionId).digest('base64'));\n\n  // Decoded session token\n  const sessionTokenBytes = Buffer.concat([sessionId, signature]);\n\n  // Generate a new \"base64 based and digitally signed Session ID\",\n  // which will be our session token\n  const sessionToken = sessionTokenBytes.toString('base64');\n\n  return sessionToken;\n};\n\n/**\n * Validate session token string,\n * using the `signingKey` as the HMAC signing key\n */\nexport const validateSessionToken = (\n  sessionToken: string,\n  signingKey: string,\n): boolean => {\n  if (!signingKey) {\n    throw new Error('Signing key is required');\n  }\n\n  // Base64 decode the session token to a slice of bytes\n  const sessionTokenBytes = Buffer.from(sessionToken, 'base64');\n\n  // Get the old session ID and its signature\n  const sessionId = sessionTokenBytes.slice(0, idLength);\n  const oldSignature = sessionTokenBytes.slice(idLength);\n\n  // Create a new HMAC hasher\n  const hmac = crypto.createHmac('sha256', signingKey);\n\n  // Calculate a new HMAC signature\n  const newSignature = Buffer.from(hmac.update(sessionId).digest('base64'));\n\n  // If the old HMAC signature and new one are not equal,\n  // it means this session token is invalid\n  if (Buffer.compare(oldSignature, newSignature)) {\n    return false;\n  }\n\n  return true;\n};\n"],"names":["signingKey","Error","sessionId","crypto","randomBytes","hmac","createHmac","signature","Buffer","from","update","digest","concat","toString","sessionToken","sessionTokenBytes","slice","oldSignature","newSignature","compare"],"mappings":"uHAgBoC,SAACA,OAC9BA,QACG,IAAIC,MAAM,+BAIZC,EAAYC,EAAOC,YAnBV,IAsBTC,EAAOF,EAAOG,WAAW,SAAUN,GAGnCO,EAAYC,OAAOC,KAAKJ,EAAKK,OAAOR,GAAWS,OAAO,kBAGlCH,OAAOI,OAAO,CAACV,EAAWK,IAIbM,SAAS,wCASd,SAClCC,EACAd,OAEKA,QACG,IAAIC,MAAM,+BAIZc,EAAoBP,OAAOC,KAAKK,EAAc,UAG9CZ,EAAYa,EAAkBC,MAAM,EArD3B,IAsDTC,EAAeF,EAAkBC,MAtDxB,IAyDTX,EAAOF,EAAOG,WAAW,SAAUN,GAGnCkB,EAAeV,OAAOC,KAAKJ,EAAKK,OAAOR,GAAWS,OAAO,kBAI3DH,OAAOW,QAAQF,EAAcC"}