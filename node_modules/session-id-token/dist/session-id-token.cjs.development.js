'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var crypto = _interopDefault(require('crypto'));

var idLength = 32;
/**
 * Generate a digitally-signed session ID (a.k.a session token).
 * This is a base64 URL encoded string created from a byte slice
 * where the first `idLength` bytes are crytographically random
 * bytes representing the unique session ID, and the remaining bytes
 * are an HMAC hash of those ID bytes (i.e., a digital signature).
 * The byte slice layout is like so:
 * +-----------------------------------------------------+
 * |...32 crypto random bytes...|HMAC hash of those bytes|
 * +-----------------------------------------------------+
 */

var generateSessionToken = function generateSessionToken(signingKey) {
  if (!signingKey) {
    throw new Error('Signing key is required');
  } // Cryptographically random bytes


  var sessionId = crypto.randomBytes(idLength); // Create a new HMAC hasher

  var hmac = crypto.createHmac('sha256', signingKey); // Calculate the HMAC signature

  var signature = Buffer.from(hmac.update(sessionId).digest('base64')); // Decoded session token

  var sessionTokenBytes = Buffer.concat([sessionId, signature]); // Generate a new "base64 based and digitally signed Session ID",
  // which will be our session token

  var sessionToken = sessionTokenBytes.toString('base64');
  return sessionToken;
};
/**
 * Validate session token string,
 * using the `signingKey` as the HMAC signing key
 */

var validateSessionToken = function validateSessionToken(sessionToken, signingKey) {
  if (!signingKey) {
    throw new Error('Signing key is required');
  } // Base64 decode the session token to a slice of bytes


  var sessionTokenBytes = Buffer.from(sessionToken, 'base64'); // Get the old session ID and its signature

  var sessionId = sessionTokenBytes.slice(0, idLength);
  var oldSignature = sessionTokenBytes.slice(idLength); // Create a new HMAC hasher

  var hmac = crypto.createHmac('sha256', signingKey); // Calculate a new HMAC signature

  var newSignature = Buffer.from(hmac.update(sessionId).digest('base64')); // If the old HMAC signature and new one are not equal,
  // it means this session token is invalid

  if (Buffer.compare(oldSignature, newSignature)) {
    return false;
  }

  return true;
};

exports.generateSessionToken = generateSessionToken;
exports.validateSessionToken = validateSessionToken;
//# sourceMappingURL=session-id-token.cjs.development.js.map
