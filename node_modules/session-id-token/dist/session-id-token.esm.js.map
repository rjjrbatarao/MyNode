{"version":3,"file":"session-id-token.esm.js","sources":["../src/index.ts"],"sourcesContent":["import crypto from 'crypto';\n\n// Length of the session ID portion\nconst idLength = 32;\n\n/**\n * Generate a digitally-signed session ID (a.k.a session token).\n * This is a base64 URL encoded string created from a byte slice\n * where the first `idLength` bytes are crytographically random\n * bytes representing the unique session ID, and the remaining bytes\n * are an HMAC hash of those ID bytes (i.e., a digital signature).\n * The byte slice layout is like so:\n * +-----------------------------------------------------+\n * |...32 crypto random bytes...|HMAC hash of those bytes|\n * +-----------------------------------------------------+\n */\nexport const generateSessionToken = (signingKey: string): string => {\n  if (!signingKey) {\n    throw new Error('Signing key is required');\n  }\n\n  // Cryptographically random bytes\n  const sessionId = crypto.randomBytes(idLength);\n\n  // Create a new HMAC hasher\n  const hmac = crypto.createHmac('sha256', signingKey);\n\n  // Calculate the HMAC signature\n  const signature = Buffer.from(hmac.update(sessionId).digest('base64'));\n\n  // Decoded session token\n  const sessionTokenBytes = Buffer.concat([sessionId, signature]);\n\n  // Generate a new \"base64 based and digitally signed Session ID\",\n  // which will be our session token\n  const sessionToken = sessionTokenBytes.toString('base64');\n\n  return sessionToken;\n};\n\n/**\n * Validate session token string,\n * using the `signingKey` as the HMAC signing key\n */\nexport const validateSessionToken = (\n  sessionToken: string,\n  signingKey: string,\n): boolean => {\n  if (!signingKey) {\n    throw new Error('Signing key is required');\n  }\n\n  // Base64 decode the session token to a slice of bytes\n  const sessionTokenBytes = Buffer.from(sessionToken, 'base64');\n\n  // Get the old session ID and its signature\n  const sessionId = sessionTokenBytes.slice(0, idLength);\n  const oldSignature = sessionTokenBytes.slice(idLength);\n\n  // Create a new HMAC hasher\n  const hmac = crypto.createHmac('sha256', signingKey);\n\n  // Calculate a new HMAC signature\n  const newSignature = Buffer.from(hmac.update(sessionId).digest('base64'));\n\n  // If the old HMAC signature and new one are not equal,\n  // it means this session token is invalid\n  if (Buffer.compare(oldSignature, newSignature)) {\n    return false;\n  }\n\n  return true;\n};\n"],"names":["idLength","generateSessionToken","signingKey","Error","sessionId","crypto","randomBytes","hmac","createHmac","signature","Buffer","from","update","digest","sessionTokenBytes","concat","sessionToken","toString","validateSessionToken","slice","oldSignature","newSignature","compare"],"mappings":";;AAGA,IAAMA,QAAQ,GAAG,EAAjB;;;;;;;;;;;;;AAaA,IAAaC,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACC,UAAD;MAC9B,CAACA,UAAL,EAAiB;UACT,IAAIC,KAAJ,CAAU,yBAAV,CAAN;;;;MAIIC,SAAS,GAAGC,MAAM,CAACC,WAAP,CAAmBN,QAAnB,CAAlB;;MAGMO,IAAI,GAAGF,MAAM,CAACG,UAAP,CAAkB,QAAlB,EAA4BN,UAA5B,CAAb;;MAGMO,SAAS,GAAGC,MAAM,CAACC,IAAP,CAAYJ,IAAI,CAACK,MAAL,CAAYR,SAAZ,EAAuBS,MAAvB,CAA8B,QAA9B,CAAZ,CAAlB;;MAGMC,iBAAiB,GAAGJ,MAAM,CAACK,MAAP,CAAc,CAACX,SAAD,EAAYK,SAAZ,CAAd,CAA1B;;;MAIMO,YAAY,GAAGF,iBAAiB,CAACG,QAAlB,CAA2B,QAA3B,CAArB;SAEOD,YAAP;CArBK;;;;;;AA4BP,IAAaE,oBAAoB,GAAG,SAAvBA,oBAAuB,CAClCF,YADkC,EAElCd,UAFkC;MAI9B,CAACA,UAAL,EAAiB;UACT,IAAIC,KAAJ,CAAU,yBAAV,CAAN;;;;MAIIW,iBAAiB,GAAGJ,MAAM,CAACC,IAAP,CAAYK,YAAZ,EAA0B,QAA1B,CAA1B;;MAGMZ,SAAS,GAAGU,iBAAiB,CAACK,KAAlB,CAAwB,CAAxB,EAA2BnB,QAA3B,CAAlB;MACMoB,YAAY,GAAGN,iBAAiB,CAACK,KAAlB,CAAwBnB,QAAxB,CAArB;;MAGMO,IAAI,GAAGF,MAAM,CAACG,UAAP,CAAkB,QAAlB,EAA4BN,UAA5B,CAAb;;MAGMmB,YAAY,GAAGX,MAAM,CAACC,IAAP,CAAYJ,IAAI,CAACK,MAAL,CAAYR,SAAZ,EAAuBS,MAAvB,CAA8B,QAA9B,CAAZ,CAArB;;;MAIIH,MAAM,CAACY,OAAP,CAAeF,YAAf,EAA6BC,YAA7B,CAAJ,EAAgD;WACvC,KAAP;;;SAGK,IAAP;CA3BK;;;;"}